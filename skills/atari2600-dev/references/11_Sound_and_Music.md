# Sound & Music

The Atari 2600’s audio is generated by the TIA using two identical sound channels.  Each channel produces square waves or noise by dividing a reference clock through linear‑feedback shift registers.  Despite its simplicity, clever use of the registers can produce music, explosions, footsteps and more.

## TIA Sound Hardware Overview

Each audio circuit uses a 5‑bit polynomial counter and divider to generate frequencies.  The channels are mixed into a single mono output.  NTSC consoles output at roughly 30 kHz for tones derived from the pixel clock and ~15 kHz for those derived from the CPU clock; PAL consoles output slightly different frequencies.  Because of the limited note resolution, you must choose pitches that sound acceptable on real hardware.

## Sound Channels and Registers

Each channel has three write‑only registers:

* **`AUDFx` (Frequency, $15/$16)** – 5‑bit value (0–31) selects the divisor for the tone generator.  A value of 0 produces the highest pitch; 31 produces the lowest.
* **`AUDCx` (Control, $17/$18)** – 4‑bit value selects the waveform or noise type.  Low values (0–3) produce bassy rumble; values (4–5) generate pure tones; (6–10) produce square waves; high values (11–15) generate white or metallic noise.
* **`AUDVx` (Volume, $19/$1A)** – 4‑bit value (0–15) controls loudness; 0 mutes the channel.

You can update these registers at any time.  When writing to `AUDFx` or `AUDCx`, the tone changes immediately; writing to `AUDVx` changes the volume instantly.

## Basic Sound Effects

Common effects can be achieved with simple register combinations:

* **Pure tones** – `AUDC` = 4 or 5 and choose `AUDF` to match the desired pitch.  For example, a 1 kHz tone on NTSC uses `AUDC4=4` and `AUDF=14`.
* **Square wave** – `AUDC` = 6, 10 or 14; combine with low `AUDF` values for buzzy sounds.
* **Noise** – `AUDC` = 12–15 produce white or metallic noise useful for explosions or engines.

Fade effects are created by gradually changing `AUDVx` over several frames.

## Music Patterns and Timing

Because the TIA lacks a music sequencer, you must implement one in software.  A typical approach stores notes as tables of pitch and duration bytes:

```asm
Track1:
    .byte NOTE_A4, 8
    .byte NOTE_B4, 8
    .byte NOTE_C5, 16
    .byte 0          ; end marker
```

During vertical blank, your music routine reads the next note, sets `AUDFx`, `AUDCx` and `AUDVx`, and decrements a duration counter each frame.  When the counter reaches zero, it advances to the next note.  Many games interleave two tracks on separate channels to create harmony.

Timing is based on the frame rate.  For example, an eighth note at 120 BPM lasts 0.25 seconds or 15 frames on NTSC.  Adjust durations for PAL (50 Hz) so the tempo remains consistent.

## Volume Envelopes and Effects

Dynamic sounds can be created by modulating volume:

* **Attack–decay–sustain–release (ADSR)** – Implement a simple envelope by incrementing `AUDVx` over several frames (attack), holding it (sustain) and then decrementing to zero (release).  This gives notes more expressiveness.
* **Vibrato** – Alternate `AUDFx` between two adjacent values every few frames to simulate pitch modulation.
* **Arpeggios** – Quickly cycle through multiple pitches within a single note to emulate chords.

Because volume writes are inexpensive, you can update envelopes during overscan without affecting the kernel.

## Common Sound Pitfalls

* **NTSC vs PAL** – Because PAL consoles run at 50 Hz and use different divider values, pitches will be lower than on NTSC.  Test your music on both systems and choose `AUDC` and `AUDF` values that sound good.
* **Limited frequency resolution** – With only 32 frequency divisors, many musical notes are off‑pitch.  Use micro‑arpeggios or vibrato to approximate missing notes.
* **Volume clicks** – Sudden changes to `AUDVx` can produce clicks.  Smooth the volume ramp when starting or stopping a sound.

Despite these limitations, the 2600’s simple sound hardware can produce surprisingly rich effects when carefully programmed.
